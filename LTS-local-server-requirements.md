# LTS 매장 로컬 서버 요구사항(뼈대)

## 목표
매장 PC 1대에서 Node.js 로컬 서버를 실행한다. 로컬 서버는 **기록 수집/파생/업로드**에만 관여하며, 게임 프로그램 자체의 동작(플레이어 갱신/운영 로직)은 변경하지 않는다.

핵심 축 3개:
1) **경기 결과(JSONL) 파일 폴링 → 변경분만 처리(멱등) → 로컬 Redis 저장 + Firebase 업로드**
2) **모바일(세로) 기준 닉네임 등록 페이지** + 직원 로그인(JWT 7일)
3) **직원 PC 운영 보드(localhost 전용, 무인증)**: 대기/게임중/종료 드래그&드롭 정리, 당일(KST 00:00)까지 기록 유지

---

## 데이터 소스와 제약
### 1) Match 결과 파일
- 형식: **JSONL** (한 줄 = 한 match JSON)
- append-only: 경기가 끝나면 레코드가 추가됨
- 종료 후 정정 데이터는 **절대 없음** (once-write)

샘플 구조(요지):
- Id, Name, LaunchTime, FinishTime, DurationSeconds
- Teams.Red / Teams.Blue: teamId, score, players[] (kills/deaths/shots/hits/accuracy/damageDealt 등)
- Result: winTeamId/winSide/resultType
- FirstBlood: killer/victim

### 2) Player 파일
- 별도 주기 폴링 금지
- **Match 결과 파일이 변할 때만** 읽는다
- 게임 프로그램이 플레이어 리스트는 알아서 갱신하며, 현재 만드는 서버는 **기록/조회용 데이터**만 다룬다
- PlayerId는 생성 시점에 음수(-) 형태로 부여되며, 유저 삭제 시 **재사용/중복 가능** (게임 프로그램 한계)

---

## 멱등(중복/재처리 방지) 모델
### 핵심 메커니즘: 파일 오프셋 체크포인트
- Match JSONL 파일은 append-only 이므로, **“어디까지 읽었는지(바이트 오프셋)”**가 곧 멱등 키다.
- 처리 흐름:
  - 폴링마다 파일 stat 확인
  - 파일 크기 증가 시: checkpoint(offset)부터 EOF까지 스트리밍 읽기
  - 라인 단위 JSON parse → FinishTime 있는 레코드만 처리
  - 처리 성공 후 checkpoint를 원자적으로 갱신

### 방어선(유니크 인덱스)
- match는 `match.Id` unique 기준으로 upsert/skip (불변이라 업데이트 필요 없음)

### PlayerId 불안정에 대한 결론
- 내부 식별에서 PlayerId를 영구 키로 쓰면 위험하다.
- 직원이 식별하는 기준은 결국 **게임 프로그램에 보이는 닉네임**이므로, 운영 품질은 “닉네임 충돌 방지”가 최우선이다.

---

## 닉네임 정책
### 기본 원칙
- 직원이 볼 수 있는 건 닉네임뿐이므로 **닉네임 중복을 원천적으로 막는다**가 최선.
- 중복 규칙: **전체 기간 중복 금지**
- 단, guest는 월 1회 삭제 정책이 있으며(예외적으로 “기존 guest 일부”는 보존), 삭제된 guest의 닉네임 재사용 허용 여부는 정책으로 고정 필요.

### 정규화 키(nickKey)
- 표시용(displayName)과 별개로, 내부 유니크 검사용 **정규화 키(nickKey)**를 둔다.
- nickKey는 유사문자/공백/대소문자 차이를 흡수해 “사실상 같은 닉네임”을 같은 키로 만든다.

### LiteDB 수정 가능성(선택)
- 게임 프로그램 DB(LiteDB)는 직접 수정할 수 없지만,
  - 마이그레이션으로 추가 필드를 넣어도 문제 없으면
  - 내부용 유니크 키(예: playerGuid 같은)를 부여해 보조키로 사용할 수 있다.
- 단, 직원 식별/운영은 여전히 닉네임 기반이므로, 보조키는 **기록 결합/검색 안정화** 정도의 역할로 제한한다.

---

## UI/인증
### 직원 로그인(모바일 등록 페이지용)
- `.env`에 STAFF_ID / STAFF_PW를 평문으로 둔다(테스트 목적)
- 로그인 성공 시 JWT 발급
  - 만료: **7일**
- 로그인 적용 범위:
  - 모바일 닉네임 등록 페이지(직원 인증 필요)
  - 그 외 운영 보드는 무인증(아래 참조)

### 직원 PC 운영 보드
- 접속: **localhost only (127.0.0.1 바인딩)**
- 무인증 접근
- 기능:
  - 등록 페이지에서 들어온 고객을 “대기중”에 자동 배치
  - 드래그&드롭으로 상태 이동: 대기중 / 게임중 / 게임 종료
  - 게임 종료로 옮긴 항목도 삭제하지 않고 **당일(KST 00:00)까지** 유지

---

## 고객 엔티티/등록 플로우(뼈대)
### 1) 비회원(guest)
- 닉네임만 입력
- 중복 검사 통과 시 등록 완료

### 2) 로그인(member)
- 전화번호 + 4자리 인증번호 UI/엔드포인트 뼈대만
- 실제 OTP 로직은 추후 구현

### 3) 회원가입(member)
- 전화번호 + 4자리 인증번호 + 닉네임
- 전화번호/닉네임 중복 검사 통과 시 Redis + Firebase 저장
- OTP 로직은 추후 구현(현재는 스켈레톤)

---

## 업로드(뼈대): OP.GG 스타일 최소 데이터만
> 고객용 페이지 자체 구현은 지금 범위 밖. 다만 나중에 OP.GG 스타일이 가능하도록 “최소 인덱스”만 업로드한다.

필수 3축:
1) `matches/{matchId}`: match 원본 또는 슬림(팀/스코어/플레이어 주요 지표/finishedAt)
2) `user_matches/{userRef}/{finishedAt_matchId}`: 유저별 최근 경기 카드용 요약(승패/내 스탯/팀스코어)
3) `rating_events/{userRef}/{ts_matchId}`: 레이팅 추이용 이벤트(현재는 비워도 스키마만)

Cloud Function은 위 데이터를 기반으로:
- 프로필 요약(최근 N게임 평균, 승률, 추이 등)
- 매치 리스트/상세
- 리더보드(기간별 TopK)
같은 정제 결과를 만들어 반환하는 방향.

---

## 시간/리셋 규칙
- “당일” 경계: **KST 00:00**
- 운영 보드/대기열/종료 기록은 당일 범위 내에서 유지

---

## 기술 스택(오마카세: 작고 AI가 잘 만드는 조합)
서버:
- Fastify + Pino
- ioredis (로컬 Redis)
- firebase-admin (업로드)
- zod (JSONL 스키마 검증)
- (선택) chokidar (변경 이벤트 트리거 보조)

프론트:
- Vite + React + TypeScript
- Tailwind + shadcn/ui (다크 + 글래스모피즘)
- dnd-kit (보드 드래그&드롭)
- TanStack Query (API 상태)
